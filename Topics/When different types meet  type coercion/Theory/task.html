<h2>When different types meet: type coercion</h2>
<div class="step-text">
<p>You already know how to perform <a class="theory-lookup" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="Type conversion, also known as type casting, in Kotlin refers to the process of changing a value from one data type to another. | This is particularly important in Kotlin because it is a statically typed language, meaning that types are identified and strictly applied at compile time. Kotlin does not allow implicit conversion to prevent precision loss or unexpected outcomes. Therefore, when you need to switch a variable from one type to another in Kotlin, explicit type conversion is necessary.">type conversion</a>. There are more advanced aspects of it: for example, you know that we cannot assign a <a class="theory-lookup" href="/learn/step/4371" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a variable is a storage for a value, which can be a string, a number, or something else. | Every variable has a name (or an identifier) to distinguish it from other variables. You can access a value by the name of the variable. Variables are one of the most often used elements in programming, so it is important to understand how to use them. Before you can start using a variable, you must declare it. To declare a variable, Kotlin provides two keywords: `val` and `var`.">variable</a> of  <code class="language-kotlin">Int</code> type to a <code class="language-kotlin">Long</code> variable. But what happens if we calculate the sum of <code class="language-kotlin">Int</code> and <code class="language-kotlin">Long</code> variables?  In this case, the type is inferred from the context. </p><h5 id="type-coercion">Type coercion</h5><p>In such cases, the compiler automatically sets all components (it's called <strong><a class="theory-lookup" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="Type coercion in Kotlin is an automatic conversion of a value from one type to another, which is wider in the type hierarchy, without any loss of information. | This occurs when the type of the result is wider than the previous type, and it is rare in Kotlin, working only with number and string types. The compiler automatically sets all components and the result type to the widest type in the expression, ensuring that there is no loss of information during the conversion.">type coercion</a></strong>) and the result type to the widest type in the expression. The picture below illustrates the direction of this casting:</p><p style="text-align: center;"><source media="(max-width: 480px)" srcset="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"><source media="(max-width: 800px)" srcset="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"><source srcset="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="The direction of transfer of variable types on the left to the right from Byte and Short to Double" height="161" src="https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/" width="801"/></picture></source></source></source></p><p>Since the type of the result is wider than the previous type, there is no loss of information. </p><p> </p><p></p><div class="alert alert-primary"><p>Type coercion is rare in Kotlin. It works only with <a class="theory-lookup" href="/learn/step/14438" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, the concept of number refers to a type of literal that represents numerical values. | These can be integers, which are whole numbers, or floating-point numbers, which include decimals. Numbers are used in programming to perform mathematical operations, manipulate data, and control the flow of a program. Kotlin's type system does not perform implicit type conversion for numbers, meaning that you need to manually convert types if you wish to assign a value of one type to a variable of another.">numbers</a> and <a class="theory-lookup" href="/learn/step/4351" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a string is a sequence of zero or more characters enclosed by double quotes. | It is a very useful data type and is often used in programming. Strings can be manipulated in various ways, such as getting their length or concatenating them with other strings.">strings</a>.</p></div><p></p><p> </p><h5 id="examples">Examples</h5><p>The theory looks pretty clear, so let's take a look at some examples of type coercion.</p><ul><li><p>from <code class="language-kotlin">Int</code> to <code class="language-kotlin">Long</code>:</p></li></ul><pre><code class="language-kotlin">val num: Int = 100
val longNum: Long = 1000
val result = num + longNum // 1100, Long</code></pre><p>Although <code class="language-kotlin">result</code> is just 1100, it is the sum of <code class="language-kotlin">Long</code> and <code class="language-kotlin">Int</code> variables, so the type is automatically cast to <code class="language-kotlin">Long</code>. If you try to declare a result as <code class="language-kotlin">Int</code>, you get an error because you cannot assign the value of  Long type to an Int variable. You can assign only an <code class="language-kotlin">Int</code> value or an <a class="theory-lookup" href="/learn/step/4488" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an integer is a type of number without a decimal point. | It can be represented by the types Int (32-bit) or Long (64-bit). You can perform arithmetic operations such as addition, subtraction, multiplication, division, and modulus with integer variables. To declare a variable of the type Int, you can use one of the following ways: by assigning a value within the range of Int, by specifying the type after the variable name, or by tagging the value with the suffix 'L'.">integer</a> number to a variable of <code class="language-kotlin">Int</code> type.</p><ul><li><p>from <code class="language-kotlin">Long</code> to <code class="language-kotlin">Double</code>:</p></li></ul><pre><code class="language-kotlin">val bigNum: Long = 100000
val doubleNum: Double = 0.0
val bigFraction = bigNum - doubleNum // 100000.0, Double</code></pre><h5 id="short-and-byte-types">Short and Byte types</h5><p>You can see how the result of an expression with variables of different types is automatically cast to the widest type. However, the <code class="language-kotlin">Byte</code> and <code class="language-kotlin">Short</code> types are unusual in this respect. If you need to do some calculations with these types, the result of the calculation is <code class="language-kotlin">Int</code>:</p><ul><li><p><code class="language-kotlin">Byte</code> and <code class="language-kotlin">Byte</code></p></li></ul><pre><code class="language-kotlin">val one: Byte = 1
val two: Byte = 2
val three = one + two // 3, Int</code></pre><ul><li><p><code class="language-kotlin">Short</code> and <code class="language-kotlin">Short</code></p></li></ul><pre><code class="language-kotlin">val fourteen: Short = 14
val ten: Short = 10
val four = fourteen - ten // 4, Int</code></pre><ul><li><p><code class="language-kotlin">Short</code> and <code class="language-kotlin">Byte</code></p></li></ul><pre><code class="language-kotlin">val hundred: Short = 100
val five: Byte = 5
val zero = hundred % five // 0, Int</code></pre><p>So what should we do if we want to sum two <code class="language-kotlin">Byte</code> variables and get a <code class="language-kotlin">Byte</code> result? Well, in this case, you must manually perform type conversion:</p><pre><code class="language-kotlin">val one: Byte = 1
val five: Byte = 5
val six = (one + five).toByte() // 6, Byte</code></pre><p>Remember that <code class="language-kotlin">Byte</code> can store data in the <a class="theory-lookup" href="/learn/step/4633" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, 'range' is a way to represent a sequence of values between a start and an end point. | It can be used with various types, but is most commonly used with integers. There are two types of ranges in Kotlin: closed-ended range and open-ended range. A closed-ended range includes both the start and end values, while an open-ended range excludes the end value. The 'in' keyword is used to check if a value is within a range.">range</a> <code class="language-kotlin">-128.. 127.</code></p><p>Look at the example below of how type <a class="theory-lookup" href="/learn/step/4488" rel="noopener noreferrer nofollow" target="_blank" title="Overflow in Kotlin refers to the situation when a value exceeds the maximum or minimum limit of its data type, causing it to wrap around and produce an incorrect result. | This can occur in arithmetic operations, such as addition, subtraction, multiplication, or division, when the operands or the result are too large to be represented accurately within the given data type's range. Kotlin's numeric types have well-defined behavior for overflow, and the language provides various mechanisms to handle or prevent it, depending on the desired outcome.">overflow</a> works:</p><pre><code class="language-kotlin">fun main() {
    val a: Byte = 120
    println((a + a).toByte()) // prints -16 because 120+120 &gt; 127
}</code></pre><p></p><h5 id="conclusion">Conclusion</h5><p>To sum up, if you have an expression with different numeric types, use these rules to know the type of the result:</p><ol><li><p>If either operand is of type <code class="language-kotlin">Double</code>, the result is <code class="language-kotlin">Double</code>.</p></li><li><p>Otherwise, if either operand is of type <code class="language-kotlin">Float</code>, the result is <code class="language-kotlin">Float</code>.</p></li><li><p>Otherwise, if either operand is of type <code class="language-kotlin">Long</code>, the result is <code class="language-kotlin">Long</code>.</p></li><li><p>Otherwise, the result is <code class="language-kotlin">Int</code>.</p></li></ol><p> </p><div class="alert alert-primary"><p>Type coercion does not occur when a value is put into the variable. For example, <code class="language-kotlin">val longValue: Long = 10.toInt()</code> is incorrect, because 10 is <code class="language-kotlin">Int</code> and <code class="language-kotlin">longValue</code> requires the <code class="language-kotlin">Long</code> type.</p></div><p>The compiler automatically deduces the type of <a class="theory-lookup" href="/learn/step/28741" rel="noopener noreferrer nofollow" target="_blank" title="An expression in Kotlin is a piece of code that evaluates to a value. | It can be a simple literal value, a variable, a function call, or a more complex combination of these elements using operators or other language constructs. Expressions are used to compute and return values from functions, assign values to variables, and perform calculations or operations in conditional statements and loops. Kotlin's expression-oriented syntax allows for a more concise and readable code, as it eliminates the need for separate statement blocks for expressions.">expression</a>. It helps you omit type conversion in simple cases, but you need to understand how it works to prevent confusion and errors.</p>
</div>
